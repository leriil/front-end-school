<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Go through the MAZE</title>
    <style>
      body {
        background-color: palegreen;
        display: flex;
        flex-flow: row nowrap;
      }

      .controls {
        display: flex;
        flex-direction: column;
        margin-left: 20px;
      }

      .result {
        display: inline-block;
        color: red;
        text-transform: uppercase;
        vertical-align: middle;
      }

      .result--success {
        color: green;
      }

      .start {
        display: inline-block;
        margin-bottom: 20px;
      }

      .field {
        position: relative;
        display: flex;
        flex-wrap: wrap;
        justify-content: flex-start;
        background-color: white;
        width: 500px;
        height: 500px;
        float: left;
      }

      .field__cell {
        flex-basis: 50px;
        height: 50px;
        box-shadow: inset 0 0 0 1px palegreen;
      }

      .field__cell--up {
        box-shadow: 0 -4px 0 0 black, inset 0 0 0 1px palegreen;
      }

      .field__cell--up-right {
        box-shadow: 0 -4px 0 0 black, 4px 0 0 0 black, inset 0 0 0 1px palegreen;
      }

      .field__cell--up-left {
        box-shadow: 0 -4px 0 0 black, -4px 0 0 black, inset 0 0 0 1px palegreen;
      }

      .field__cell--right {
        box-shadow: 4px 0 0 0 black, inset 0 0 0 1px palegreen;
      }

      .field__cell--down {
        box-shadow: 0 4px 0 0 black, inset 0 0 0 1px palegreen;
      }

      .field__cell--down-right {
        box-shadow: 0 4px 0 0 black, 4px 0 0 0 black, inset 0 0 0 1px palegreen;
      }

      .field__cell--down-left {
        box-shadow: 0 4px 0 0 black, -4px 0 0 black, inset 0 0 0 1px palegreen;
      }

      .field__cell--left {
        box-shadow: -4px 0 0 black, inset 0 0 0 1px palegreen;
      }

      .field__cell--target:after {
        content: '';
        display: block;
        height: 100%;
        width: 100%;
        background-color: darkorange;
        opacity: 0.5;
      }

      .piece {
        position: absolute;
        z-index: 1;
        width: 50px;
        height: 50px;
      }

      .piece:before,
      .piece:after {
        content: '';
        display: block;
        position: absolute;
        top: 50%;
        left: 50%;
        margin-left: -15px;
      }

      .piece:after {
        background-color: darkorange;
        border-radius: 7px;
        z-index: 1;
        width: 30px;
        height: 30px;
        box-shadow: 0 0 0 3px darkorange;
        margin-top: -15px;
      }

      .piece:before {
        background-color: transparent;
        z-index: 2;
        border: solid 15px transparent;
        width: 0;
        height: 0;
        border-bottom: solid 15px white;
        margin-top: -25px;
      }
    </style>
  </head>
  <body>
    <div class="field">
      <div class="piece" style="top: 0; left: 0; display: none;"></div>
      <div class="field__cell field__cell--up-left"></div>
      <div class="field__cell field__cell--up"></div>
      <div class="field__cell field__cell--up"></div>
      <div class="field__cell field__cell--up"></div>
      <div class="field__cell field__cell--up"></div>
      <div class="field__cell field__cell--up"></div>
      <div class="field__cell field__cell--up"></div>
      <div class="field__cell field__cell--up"></div>
      <div class="field__cell field__cell--up"></div>
      <div class="field__cell field__cell--up-right"></div>

      <div class="field__cell field__cell--up-left"></div>
      <div class="field__cell field__cell--up"></div>
      <div class="field__cell field__cell--up"></div>
      <div class="field__cell field__cell--up"></div>
      <div class="field__cell field__cell--up"></div>
      <div class="field__cell field__cell--up"></div>
      <div class="field__cell field__cell--up"></div>
      <div class="field__cell field__cell--up"></div>
      <div class="field__cell field__cell--up-right"></div>
      <div class="field__cell field__cell--right"></div>

      <div class="field__cell field__cell--left"></div>
      <div class="field__cell field__cell--up-left"></div>
      <div class="field__cell field__cell--up"></div>
      <div class="field__cell field__cell--up"></div>
      <div class="field__cell field__cell--up"></div>
      <div class="field__cell field__cell--up"></div>
      <div class="field__cell field__cell--up"></div>
      <div class="field__cell field__cell--up-right"></div>
      <div class="field__cell field__cell--right"></div>
      <div class="field__cell field__cell--right"></div>

      <div class="field__cell field__cell--left"></div>
      <div class="field__cell field__cell--left"></div>
      <div class="field__cell field__cell--up-left"></div>
      <div class="field__cell field__cell--up"></div>
      <div class="field__cell field__cell--up"></div>
      <div class="field__cell field__cell--up"></div>
      <div class="field__cell field__cell--up-right"></div>
      <div class="field__cell field__cell--right"></div>
      <div class="field__cell field__cell--right"></div>
      <div class="field__cell field__cell--right"></div>

      <div class="field__cell field__cell--left"></div>
      <div class="field__cell field__cell--left"></div>
      <div class="field__cell field__cell--left"></div>
      <div class="field__cell field__cell--up-left"></div>
      <div class="field__cell field__cell--up"></div>
      <div class="field__cell field__cell--up-right"></div>
      <div class="field__cell field__cell--right"></div>
      <div class="field__cell field__cell--right"></div>
      <div class="field__cell field__cell--right"></div>
      <div class="field__cell field__cell--right"></div>

      <div class="field__cell field__cell--left"></div>
      <div class="field__cell field__cell--left"></div>
      <div class="field__cell field__cell--left"></div>
      <div class="field__cell field__cell--left"></div>
      <div class="field__cell field__cell--up-left"></div>
      <div class="field__cell field__cell--down-right"></div>
      <div class="field__cell field__cell--right"></div>
      <div class="field__cell field__cell--right"></div>
      <div class="field__cell field__cell--right"></div>
      <div class="field__cell field__cell--right"></div>

      <div class="field__cell field__cell--left"></div>
      <div class="field__cell field__cell--left"></div>
      <div class="field__cell field__cell--left"></div>
      <div class="field__cell field__cell--left"></div>
      <div class="field__cell field__cell--down-left"></div>
      <div class="field__cell field__cell--down"></div>
      <div class="field__cell field__cell--down-right"></div>
      <div class="field__cell field__cell--right"></div>
      <div class="field__cell field__cell--right"></div>
      <div class="field__cell field__cell--right"></div>

      <div class="field__cell field__cell--left"></div>
      <div class="field__cell field__cell--left"></div>
      <div class="field__cell field__cell--left"></div>
      <div class="field__cell field__cell--down-left"></div>
      <div class="field__cell field__cell--down"></div>
      <div class="field__cell field__cell--down"></div>
      <div class="field__cell field__cell--down"></div>
      <div class="field__cell field__cell--down-right"></div>
      <div class="field__cell field__cell--right"></div>
      <div class="field__cell field__cell--right"></div>

      <div class="field__cell field__cell--left"></div>
      <div class="field__cell field__cell--left"></div>
      <div class="field__cell field__cell--down-left"></div>
      <div class="field__cell field__cell--down"></div>
      <div class="field__cell field__cell--down"></div>
      <div class="field__cell field__cell--down"></div>
      <div class="field__cell field__cell--down"></div>
      <div class="field__cell field__cell--down"></div>
      <div class="field__cell field__cell--down-right"></div>
      <div class="field__cell field__cell--right"></div>

      <div class="field__cell field__cell--left field__cell--target"></div>
      <div class="field__cell field__cell--down-left"></div>
      <div class="field__cell field__cell--down"></div>
      <div class="field__cell field__cell--down"></div>
      <div class="field__cell field__cell--down"></div>
      <div class="field__cell field__cell--down"></div>
      <div class="field__cell field__cell--down"></div>
      <div class="field__cell field__cell--down"></div>
      <div class="field__cell field__cell--down"></div>
      <div class="field__cell field__cell--down-right"></div>
    </div>

    <div class="controls">
      <div>
        <button class="start">Start</button>
      </div>
      <div class="result"></div>
    </div>

    <script>
      const successResult = 'success!';
      const failResult = 'fail!';
      const successModifier = 'result--success';
      const start = document.querySelector('.start');
      const result = document.querySelector('.result');
      const fieldElement = document.querySelector('.field');
      const cellsElements = document.querySelectorAll('.field__cell');
      const pieceElement = document.querySelector('.piece');
      const directionNames = ['up', 'right', 'down', 'left'];
      let stepper;
      //у поля есть поле, клетки, противоположные направления
      class Field {
        constructor() {
          this.field = fieldElement;
          this.cells = cellsElements;
          this.opposites = {
            up: 'down',
            down: 'up',
            left: 'right',
            right: 'left',
          };
        }
        //true/false в зависимости от того, распологаются ли клетки в одной строке
        onTheSameRow(current, next) {
          return (current - (current % 10)) / 10 === (next - (next % 10)) / 10;
        }

        findNextCell(currentIndex, direction) {
          let nextIndex = currentIndex;

          switch (direction) {
            //возвращает -1 если выше клетки нет, либо номер следующей клетки выше
            case 'up':
              nextIndex = currentIndex - 10;
              if (nextIndex < 0) {
                nextIndex = -1;
              }
              break;
            //возвращает номер следующей клетки справа или -1, если этот номер оказался не в той же строке
            case 'right':
              nextIndex = currentIndex + 1;
              if (!this.onTheSameRow(currentIndex, nextIndex)) {
                nextIndex = -1;
              }
              break;
            //возвращает -1 если выше клетки нет, либо номер следующей клетки ниже
            case 'down':
              nextIndex = currentIndex + 10;
              if (nextIndex > 100) {
                nextIndex = -1;
              }
              break;
            //возвращает номер следующей клетки слева или -1, если этот номер оказался не в той же строке
            case 'left':
              nextIndex = currentIndex - 1;
              if (!this.onTheSameRow(currentIndex, nextIndex)) {
                nextIndex = -1;
              }
              break;

            default:
              nextIndex = -1;
              break;
          }
          //вернет undefined если клетки нет, либо номер следующей клетки
          return this.cells[nextIndex];
        }
        //по текущему номеру клетки и направлению фигурки определяет, есть ли на пути стена
        isTheWallThere(position, direction) {
          let cellIndex = position.top * 10 + position.left;
          let cell = this.cells[cellIndex];
          let nextCell = this.findNextCell(cellIndex, direction);
          //   console.log(cell.classList.toString());
          // console.log(cell.classList.toString().indexOf(direction));
          return (
            cell.classList.toString().indexOf(direction) !== -1 ||
            typeof nextCell === 'undefined' ||
            nextCell.classList.toString().indexOf(this.opposites[direction]) !==
              -1
          );
        }
      }
      //создает поле
      function createPiece() {
        let field = new Field();
        //меняет направление на 90 градусов (по часовой стрелке)
        let rotatePiece = direction => {
          let dir = direction;
          //записывает в ходы поворот фишки
          moves.unshift(function() {
            pieceElement.style.transform = 'rotate(' + dir * 90 + 'deg)';
          });
        };
        //меняет позицию фишки
        let movePiece = position => {
          let top = position.top * 50;
          let left = position.left * 50;
          //записывает в ходы изменение позиции фишки
          moves.unshift(function() {
            pieceElement.style.top = top + 'px';
            pieceElement.style.left = left + 'px';
          });
        };
        //возвращает true, если фишка стоит на выигрышной клетке
        let isPieceOut = () => {
          return (
            pieceElement.style.top === '450px' &&
            pieceElement.style.left === '0px'
          );
        };
        // задает рандомно направление и положение фишки
        let direction = Math.floor(Math.random() * directionNames.length);
        let stepsCount = 0;
        let turnsCount = 0;
        let moves = [];
        let position = {
          left: Math.floor(Math.random() * 10),
          top: Math.floor(Math.random() * 10),
        };

        let piecePublicApi = {
          //возращает true если нет стены и есть следующая свободная клетка
          isThereWay() {
            const isTheWallThere = field.isTheWallThere(
              position,
              directionNames[direction],
            );
            return !isTheWallThere;
          },
          //меняет направление фишки но не передвигает
          turnLeft() {
            turnsCount += 1;
            direction -= 1;
            direction = direction < 0 ? 3 : direction;
            rotatePiece(direction);
          },
          //меняет направление фишки но не передвигает
          turnRight() {
            turnsCount += 1;
            direction += 1;
            direction = direction > 3 ? 0 : direction;
            rotatePiece(direction);
          },

          goForward() {
            stepsCount += 1;
            //если нет следующей клетки или есть стена, вернет false
            if (!this.isThereWay()) {
              return false;
            }
            //меняет позицию клетки в зависимости от направления
            switch (direction) {
              case 0:
                position.top -= 1;
                break;
              case 1:
                position.left += 1;
                break;
              case 2:
                position.top += 1;
                break;
              case 3:
                position.left -= 1;
                break;
              default:
                return false;
            }
            //двигает фишку в нужном направлении (должно быть видно)
            movePiece(position);
          },
          //=isPieceOut() - true/false - ориентир на выигрышную клетку
          amIFree() {
            return isPieceOut();
          },
        };
        //с интервалом 200мс выполняются след действия
        stepper = setInterval(() => {
          //возращает последний элемент массива
          // console.log('internval');
          // console.log(Date.now());
          let nextMove = moves.pop();
          console.log(moves);
          //если это функция - вызывает ee, иначе проверяет вышла ли фишка из лабиринта
          //если вышла, появляется сообщение 'success', если не вышла 'fail'
          if (typeof nextMove === 'function') {
            nextMove();
            // console.log(Date.now());
          } else {
            let success = isPieceOut();

            if (success) {
              result.textContent = successResult;
              result.classList.add(successModifier);
            } else {
              result.textContent = failResult;
              result.classList.remove(successModifier);
            }
            //убирает таймер и выводит в консоль количество шагов и поворотов
            clearInterval(stepper);
            console.log({ stepsCount, turnsCount });
          }
        }, 200);

        pieceElement.style.top = position.top * 50 + 'px';
        pieceElement.style.left = position.left * 50 + 'px';
        pieceElement.style.transform = 'rotate(' + direction * 90 + 'deg)';
        pieceElement.style.display = 'block';

        return piecePublicApi;
      }

      function resetField() {
        clearInterval(stepper);
        result.textContent = '';
        result.classList.remove(successModifier);
      }

      function escapePlan() {
        const piece = createPiece();
        let thereisway = piece.isThereWay();

        makeAMove = () => {
          let timerId = setInterval(() => {
            if (piece.amIFree()) {
              console.log('I am free!');
              clearInterval(timerId);
            } else {
              if (piece.isThereWay()) {
                setTimeout(() => {
                  piece.goForward();
                }, 180);
              }
              if (!piece.isThereWay()) {
                piece.turnRight();

                if (!piece.isThereWay()) {
                  piece.turnLeft();
                  piece.turnLeft();
                  if (!piece.isThereWay()) {
                    piece.turnLeft();
                  }
                }
              }
              piece.goForward();
              console.log('I made a move');
            }
          }, 150);
        };
        // вызов
        makeAMove();
      }

      function main() {
        resetField();
        escapePlan();
      }

      start.addEventListener('click', main);
    </script>
  </body>
</html>
